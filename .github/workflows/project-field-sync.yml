name: Project field sync (labels -> fields)

on:
  issues:
    types: [labeled, unlabeled, edited, reopened]
  pull_request:
    types: [labeled, unlabeled, edited, ready_for_review, reopened, closed]

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
      repository-projects: write
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            // ===== CONFIG =====
            const OWNER = "phys-sims";         // org or username that owns the Project
            const OWNER_KIND = "org";           // "org" or "user"
            const PROJECT_NUMBER = null;           // set to a number, or null if using title
            const PROJECT_TITLE = "CPA 2025 - APS March";         // set to a string, or null to use number

            const FIELD_STATUS   = "Status";    // Single-select
            const FIELD_AREA     = "Area";      // Single-select
            const FIELD_PRIORITY = "Priority";  // Single-select

            const MAP_STATUS = {
              "status:ready": "Ready",
              "status:in-progress": "In Progress",
              "status:blocked": "Blocked"
            };
            const MAP_AREA = {
              "area:phys-pipeline":  "phys-pipeline",
              "area:abcdef-sim":     "abcdef-sim",
              "area:research-utils": "research-utils",
              "area:cpa-sim":        "cpa-sim"
            };
            const MAP_PRIORITY = {
              "prio:P0": "P0",
              "prio:P1": "P1",
              "prio:P2": "P2"
            };
            // ===================

            const isIssue = !!context.payload.issue;
            const isPR = !!context.payload.pull_request;
            if (!isIssue && !isPR) {
              core.info("Not an issue or PR event; exiting.");
              return;
            }

            const contentNodeId = isIssue
              ? context.payload.issue.node_id
              : context.payload.pull_request.node_id;

            async function resolveProject() {
              if (OWNER_KIND === "org") {
                if (PROJECT_TITLE && PROJECT_TITLE.length > 0) {
                  const q = `
                    query($login:String!){
                      organization(login:$login){
                        projectsV2(first:50){
                          nodes { id number title }
                        }
                      }
                    }`;
                  const { organization } = await github.graphql(q, { login: OWNER });
                  const match = (organization.projectsV2.nodes || []).find(p => p.title === PROJECT_TITLE);
                  if (!match) {
                    core.setFailed('No org project titled "' + PROJECT_TITLE + '" under ' + OWNER +
                                   '. Found: ' + organization.projectsV2.nodes.map(p => p.number + ":" + p.title).join(", "));
                    return null;
                  }
                  core.info("Resolved org project #" + match.number + ' "' + match.title + '"');
                  return match;
                } else {
                  if (typeof PROJECT_NUMBER !== "number") {
                    core.setFailed("PROJECT_NUMBER must be a number or set PROJECT_TITLE.");
                    return null;
                  }
                  const q = `
                    query($login:String!, $number:Int!){
                      organization(login:$login){
                        projectV2(number:$number){ id number title }
                      }
                    }`;
                  const { organization } = await github.graphql(q, { login: OWNER, number: PROJECT_NUMBER });
                  if (!organization || !organization.projectV2) {
                    core.setFailed("Could not resolve org project number " + PROJECT_NUMBER + " under " + OWNER + ".");
                    return null;
                  }
                  return organization.projectV2;
                }
              } else if (OWNER_KIND === "user") {
                if (PROJECT_TITLE && PROJECT_TITLE.length > 0) {
                  const q = `
                    query($login:String!){
                      user(login:$login){
                        projectsV2(first:50){
                          nodes { id number title }
                        }
                      }
                    }`;
                  const { user } = await github.graphql(q, { login: OWNER });
                  const match = (user.projectsV2.nodes || []).find(p => p.title === PROJECT_TITLE);
                  if (!match) {
                    core.setFailed('No user project titled "' + PROJECT_TITLE + '" under ' + OWNER +
                                   '. Found: ' + user.projectsV2.nodes.map(p => p.number + ":" + p.title).join(", "));
                    return null;
                  }
                  core.info("Resolved user project #" + match.number + ' "' + match.title + '"');
                  return match;
                } else {
                  if (typeof PROJECT_NUMBER !== "number") {
                    core.setFailed("PROJECT_NUMBER must be a number or set PROJECT_TITLE.");
                    return null;
                  }
                  const q = `
                    query($login:String!, $number:Int!){
                      user(login:$login){
                        projectV2(number:$number){ id number title }
                      }
                    }`;
                  const { user } = await github.graphql(q, { login: OWNER, number: PROJECT_NUMBER });
                  if (!user || !user.projectV2) {
                    core.setFailed("Could not resolve user project number " + PROJECT_NUMBER + " under " + OWNER + ".");
                    return null;
                  }
                  return user.projectV2;
                }
              } else {
                core.setFailed('OWNER_KIND must be "org" or "user".');
                return null;
              }
            }

            async function fetchFields(projectId) {
              const q = `
                query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2{
                      id
                      fields(first:100){
                        nodes{
                          __typename
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                          ... on ProjectV2IterationField { id name configuration { iterations { id title startDate } } }
                        }
                      }
                    }
                  }
                }`;
              const { node } = await github.graphql(q, { projectId: projectId });
              if (!node) {
                core.setFailed("Failed to fetch fields for project.");
                return null;
              }
              const byName = {};
              for (const f of node.fields.nodes) {
                if (f && f.name) byName[f.name] = f;
              }
              return byName;
            }

            async function ensureItem(projectId, contentId) {
              const add = `
                mutation($projectId:ID!, $contentId:ID!){
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } }
                }`;
              try {
                const resp = await github.graphql(add, { projectId: projectId, contentId: contentId });
                return resp.addProjectV2ItemById.item.id;
              } catch (e) {
                core.info("Add failed (likely already present). Looking up item id...");
              }

              let cursor = null;
              while (true) {
                const q = `
                  query($projectId:ID!, $after:String){
                    node(id:$projectId){
                      ... on ProjectV2{
                        items(first:100, after:$after){
                          nodes{
                            id
                            content { __typename ... on Issue { id } ... on PullRequest { id } }
                          }
                          pageInfo { hasNextPage endCursor }
                        }
                      }
                    }
                  }`;
                const { node } = await github.graphql(q, { projectId: projectId, after: cursor });
                const nodes = node.items.nodes || [];
                const hit = nodes.find(n => n.content && n.content.id === contentId);
                if (hit) return hit.id;
                const pi = node.items.pageInfo;
                if (!pi.hasNextPage) break;
                cursor = pi.endCursor;
              }
              return null;
            }

            function pick(map, labelSet) {
              const keys = Object.keys(map);
              for (const k of keys) {
                if (labelSet.has(k)) return map[k];
              }
              return null;
            }

            function getSelectOptionId(fieldsByName, fieldName, optionName) {
              const f = fieldsByName[fieldName];
              if (!f || !f.options) return null;
              const opt = f.options.find(o => o.name === optionName);
              return opt ? opt.id : null;
            }

            async function setSingleSelect(projectId, itemId, fieldId, optionId) {
              const m = `
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId,
                    fieldId:$fieldId, value:{ singleSelectOptionId:$optionId }
                  }){ clientMutationId }
                }`;
              await github.graphql(m, { projectId: projectId, itemId: itemId, fieldId: fieldId, optionId: optionId });
            }

            // Main
            const project = await resolveProject();
            if (!project) return;

            const fieldsByName = await fetchFields(project.id);
            if (!fieldsByName) return;

            const itemId = await ensureItem(project.id, contentNodeId);
            if (!itemId) {
              core.setFailed("Could not find or create project item for this content.");
              return;
            }

            const labels = isIssue
              ? (context.payload.issue.labels || []).map(l => l.name)
              : (context.payload.pull_request.labels || []).map(l => l.name);
            const labelSet = new Set(labels);

            const statusVal = pick(MAP_STATUS, labelSet);
            const areaVal   = pick(MAP_AREA, labelSet);
            const prioVal   = pick(MAP_PRIORITY, labelSet);

            const updates = [];

            if (statusVal) {
              const optId = getSelectOptionId(fieldsByName, FIELD_STATUS, statusVal);
              if (!optId) {
                core.warning('No option "' + statusVal + '" in field "' + FIELD_STATUS + '". Available: ' +
                  ((fieldsByName[FIELD_STATUS] && fieldsByName[FIELD_STATUS].options) ? fieldsByName[FIELD_STATUS].options.map(o => o.name).join(", ") : ""));
              } else {
                updates.push({ fieldId: fieldsByName[FIELD_STATUS].id, optionId: optId });
              }
            }

            if (areaVal) {
              const optId = getSelectOptionId(fieldsByName, FIELD_AREA, areaVal);
              if (!optId) {
                core.warning('No option "' + areaVal + '" in field "' + FIELD_AREA + '". Available: ' +
                  ((fieldsByName[FIELD_AREA] && fieldsByName[FIELD_AREA].options) ? fieldsByName[FIELD_AREA].options.map(o => o.name).join(", ") : ""));
              } else {
                updates.push({ fieldId: fieldsByName[FIELD_AREA].id, optionId: optId });
              }
            }

            if (prioVal) {
              const optId = getSelectOptionId(fieldsByName, FIELD_PRIORITY, prioVal);
              if (!optId) {
                core.warning('No option "' + prioVal + '" in field "' + FIELD_PRIORITY + '". Available: ' +
                  ((fieldsByName[FIELD_PRIORITY] && fieldsByName[FIELD_PRIORITY].options) ? fieldsByName[FIELD_PRIORITY].options.map(o => o.name).join(", ") : ""));
              } else {
                updates.push({ fieldId: fieldsByName[FIELD_PRIORITY].id, optionId: optId });
              }
            }

            if (updates.length === 0) {
              core.info("No mapped labels present; nothing to update.");
              return;
            }

            for (const u of updates) {
              await setSingleSelect(project.id, itemId, u.fieldId, u.optionId);
            }

            core.info("Project fields updated from labels.");

name: Project field sync (labels -> fields)

on:
  issues:
    types: [opened, edited, reopened, labeled, unlabeled]
  pull_request_target:
    types: [opened, edited, reopened, ready_for_review, synchronize, labeled, unlabeled, closed]
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    if: ${{ github.actor != 'dependabot[bot]' }}

    steps:
      - name: Assert PAT present
        run: |
          if [ -z "${{ secrets.ADD_TO_PROJECT_PAT }}" ]; then
            echo "ADD_TO_PROJECT_PAT is not available to this repo/event."
            exit 1
          fi

      - name: Sync fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            // ===== CONFIG =====
            const OWNER = "phys-sims";
            const OWNER_KIND = "org";

            const PROJECT_NUMBER = 2;
            const PROJECT_TITLE  = null;

            // Field names (must match Project exactly)
            const FIELD_STATUS    = "Status";         // single-select
            const FIELD_PRIORITY  = "Priority";       // single-select
            const FIELD_SIZE      = "Size";           // single-select
            const FIELD_ESTIMATE  = "Estimate (hrs)"; // number
            const FIELD_AREA      = "Area";           // single-select
            const FIELD_ACTUAL    = "Actual (hrs)";   // number
            const FIELD_RISK      = "Risk";           // single-select
            const FIELD_BLOCKEDBY = "Blocked By";     // text
            const FIELD_DELIV     = "Deliverable";    // single-select  <-- important

            // Label -> option mappings (option names are case-sensitive)
            const MAP_STATUS = {
              "status:backlog":     "Backlog",
              "status:ready":       "Ready",
              "status:in-progress": "In progress",
              "status:review":      "In review",
              "status:done":        "Done"
            };
            const MAP_AREA = {
              "area:phys-pipeline":  "phys-pipeline",
              "area:abcdef-sim":     "abcdef-sim",
              "area:cpa-sim":        "cpa-sim",
              "area:research-utils": "research-utils",
              "area:infra/docs":     "infra/docs"
            };
            const MAP_PRIORITY = { "prio:P0":"P0", "prio:P1":"P1", "prio:P2":"P2" };
            const MAP_SIZE     = { "size:XS":"XS","size:S":"S","size:M":"M","size:L":"L","size:XL":"XL" };
            const MAP_RISK     = { "risk:Low":"Low","risk:Med":"Med","risk:High":"High" };
            const MAP_DELIV    = { "deliverable:plot":"plot","deliverable:unit-tests":"unit-tests","deliverable:benchmark":"benchmark","deliverable:doc":"doc" };

            const DEFAULT_STATUS_ON_OPEN = "Backlog";
            // ===================

            // --- helpers ---
            function firstMatch(map, labelSet){
              for(const k of Object.keys(map)) if(labelSet.has(k)) return map[k];
              return null;
            }
            function readFormField(body, heading){
              if(!body) return null;
              const re = new RegExp(`\\n###\\s*${heading}\\s*\\n([\\s\\S]*?)(\\n###|$)`,"i");
              const m = body.match(re);
              if(!m) return null;
              const val = m[1].trim().split("\n").map(s=>s.trim()).filter(Boolean)[0];
              return val || null;
            }
            function readNumber(body, heading){
              const raw = readFormField(body, heading);
              if(!raw) return null;
              const m = raw.replace(/[, ]/g,"").match(/-?\\d+(\\.\\d+)?/);
              return m ? Number(m[0]) : null;
            }
            function normalizeDeliverable(s){
              if(!s) return null;
              const t = s.toLowerCase().trim();
              if (t.includes(",")) { // take first token if comma-separated
                return normalizeDeliverable(t.split(",")[0]);
              }
              if (t === "unit tests" || t === "unittests" || t === "unit_test") return "unit-tests";
              if (t === "bench" || t === "benchmarking") return "benchmark";
              if (t === "plots") return "plot";
              if (t === "docs" || t === "documentation") return "doc";
              return t;
            }

            async function listAllProjects(ownerKind, owner){
              const nodes = []; let after = null;
              while(true){
                const q = ownerKind === "org" ? `
                  query($login:String!, $after:String){
                    organization(login:$login){
                      projectsV2(first:100, after:$after){
                        nodes { id number title }
                        pageInfo { hasNextPage endCursor }
                      }
                    }
                  }` : `
                  query($login:String!, $after:String){
                    user(login:$login){
                      projectsV2(first:100, after:$after){
                        nodes { id number title }
                        pageInfo { hasNextPage endCursor }
                      }
                    }
                  }`;
                const data = await github.graphql(q, { login: owner, after });
                const container = ownerKind === "org" ? data.organization : data.user;
                if(!container) break;
                nodes.push(...(container.projectsV2.nodes || []));
                const pi = container.projectsV2.pageInfo;
                if(!pi?.hasNextPage) break;
                after = pi.endCursor;
              }
              return nodes;
            }

            async function resolveProject(){
              if (typeof PROJECT_NUMBER === "number"){
                const q = OWNER_KIND === "org" ? `
                  query($login:String!, $number:Int!){
                    organization(login:$login){
                      projectV2(number:$number){ id number title }
                    }
                  }` : `
                  query($login:String!, $number:Int!){
                    user(login:$login){
                      projectV2(number:$number){ id number title }
                    }
                  }`;
                const data = await github.graphql(q, { login: OWNER, number: PROJECT_NUMBER });
                const container = OWNER_KIND === "org" ? data.organization : data.user;
                if (container?.projectV2) return container.projectV2;
              }
              if (PROJECT_TITLE){
                const all = await listAllProjects(OWNER_KIND, OWNER);
                const hit = all.find(p => p.title === PROJECT_TITLE);
                if (hit) return hit;
                core.setFailed(`Project "${PROJECT_TITLE}" not found.`);
                return null;
              }
              core.setFailed("Set PROJECT_NUMBER or PROJECT_TITLE.");
              return null;
            }

            async function fetchFields(projectId){
              // We only need names and options; types come from presence of options
              const q = `
                query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2{
                      id
                      fields(first:100){
                        nodes{
                          __typename
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                          ... on ProjectV2IterationField { id name }
                        }
                      }
                    }
                  }
                }`;
              const { node } = await github.graphql(q, { projectId });
              const byName = {};
              for (const f of node.fields.nodes || []) if (f?.name) byName[f.name] = f;
              return byName;
            }

            async function ensureItem(projectId, contentId){
              const add = `
                mutation($projectId:ID!, $contentId:ID!){
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } }
                }`;
              try {
                const resp = await github.graphql(add, { projectId, contentId });
                return resp.addProjectV2ItemById.item.id;
              } catch (e) {
                // already exists; scan
              }
              let after = null;
              while(true){
                const q = `
                  query($projectId:ID!, $after:String){
                    node(id:$projectId){
                      ... on ProjectV2{
                        items(first:100, after:$after){
                          nodes{ id content { __typename ... on Issue { id } ... on PullRequest { id } } }
                          pageInfo { hasNextPage endCursor }
                        }
                      }
                    }
                  }`;
                const { node } = await github.graphql(q, { projectId, after });
                const hit = (node?.items?.nodes || []).find(n => n.content && n.content.id === contentId);
                if (hit) return hit.id;
                const pi = node?.items?.pageInfo;
                if (!pi?.hasNextPage) break;
                after = pi.endCursor;
              }
              return null;
            }

            async function setSelect(projectId, itemId, fieldId, optionId){
              const m = `
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ singleSelectOptionId:$optionId }
                  }){ clientMutationId }
                }`;
              await github.graphql(m, { projectId, itemId, fieldId, optionId });
            }
            async function setNumber(projectId, itemId, fieldId, num){
              const m = `
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $num:Float!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ number:$num }
                  }){ clientMutationId }
                }`;
              await github.graphql(m, { projectId, itemId, fieldId, num });
            }
            async function setText(projectId, itemId, fieldId, text){
              const m = `
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $text:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ text:$text }
                  }){ clientMutationId }
                }`;
              await github.graphql(m, { projectId, itemId, fieldId, text });
            }
            function getSelectOptionId(fieldsByName, fieldName, optionName){
              const f = fieldsByName[fieldName];
              if (!f || !f.options) return null;
              // case-sensitive match first, then case-insensitive
              let opt = f.options.find(o => o.name === optionName);
              if (!opt) opt = f.options.find(o => o.name.toLowerCase() === optionName.toLowerCase());
              return opt ? opt.id : null;
            }

            // ---- MAIN ----
            const isIssue = !!context.payload.issue;
            const isPR    = !!context.payload.pull_request;
            if (!isIssue && !isPR) return;

            const project = await resolveProject();
            if (!project) return;

            const fields = await fetchFields(project.id);
            const contentNodeId = isIssue ? context.payload.issue.node_id : context.payload.pull_request.node_id;
            const itemId = await ensureItem(project.id, contentNodeId);
            if (!itemId) { core.setFailed("Item not found/created in project."); return; }

            const labels = new Set(
              (isIssue
                ? (context.payload.issue.labels || []).map(l => l.name)
                : (context.payload.pull_request.labels || []).map(l => l.name)
              ) || []
            );
            const body = isIssue ? (context.payload.issue.body || "") : (context.payload.pull_request?.body || "");
            const action = context.payload.action;
            const merged = isPR ? !!context.payload.pull_request.merged : false;

            // --- select values (labels first, then form) ---
            let statusVal = firstMatch(MAP_STATUS, labels);
            let areaVal   = firstMatch(MAP_AREA, labels)   || readFormField(body, "Area");
            let prioVal   = firstMatch(MAP_PRIORITY, labels);
            let sizeVal   = firstMatch(MAP_SIZE, labels)    || readFormField(body, "Size");
            let riskVal   = firstMatch(MAP_RISK, labels)    || readFormField(body, "Risk");

            // Deliverable (single-select)
            let delivVal  = firstMatch(MAP_DELIV, labels)   || normalizeDeliverable(readFormField(body, "Deliverable"));
            if (!delivVal) {
              // very light heuristic: infer from acceptance text if present
              const t = (body||"").toLowerCase();
              if (t.includes("unit test")) delivVal = "unit-tests";
              else if (t.includes("bench")) delivVal = "benchmark";
              else if (t.includes("plot") || t.includes("notebook")) delivVal = "plot";
              else if (t.includes("docstring") || t.includes("readme") || t.includes("doc")) delivVal = "doc";
            }

            if (!statusVal && action === "opened") statusVal = DEFAULT_STATUS_ON_OPEN;
            if (isPR && action === "closed" && merged) statusVal = "Done";

            // --- numbers/text from form ---
            const estNum  = readNumber(body, "Estimate (hrs)");
            const actNum  = readNumber(body, "Actual (hrs)"); // optional
            const blocked = readFormField(body, "Blocked by") || readFormField(body, "Blocked By") || readFormField(body, "Block By");

            // --- apply
            const updates = [];

            if (statusVal && fields[FIELD_STATUS]) {
              const optId = getSelectOptionId(fields, FIELD_STATUS, statusVal);
              if (optId) updates.push(() => setSelect(project.id, itemId, fields[FIELD_STATUS].id, optId));
            }
            if (areaVal && fields[FIELD_AREA]) {
              const optId = getSelectOptionId(fields, FIELD_AREA, areaVal);
              if (optId) updates.push(() => setSelect(project.id, itemId, fields[FIELD_AREA].id, optId));
            }
            if (prioVal && fields[FIELD_PRIORITY]) {
              const optId = getSelectOptionId(fields, FIELD_PRIORITY, prioVal);
              if (optId) updates.push(() => setSelect(project.id, itemId, fields[FIELD_PRIORITY].id, optId));
            }
            if (sizeVal && fields[FIELD_SIZE]) {
              const optId = getSelectOptionId(fields, FIELD_SIZE, sizeVal);
              if (optId) updates.push(() => setSelect(project.id, itemId, fields[FIELD_SIZE].id, optId));
            }
            if (riskVal && fields[FIELD_RISK]) {
              const optId = getSelectOptionId(fields, FIELD_RISK, riskVal);
              if (optId) updates.push(() => setSelect(project.id, itemId, fields[FIELD_RISK].id, optId));
            }
            if (Number.isFinite(estNum) && fields[FIELD_ESTIMATE]) {
              updates.push(() => setNumber(project.id, itemId, fields[FIELD_ESTIMATE].id, estNum));
            }
            if (Number.isFinite(actNum) && fields[FIELD_ACTUAL]) {
              updates.push(() => setNumber(project.id, itemId, fields[FIELD_ACTUAL].id, actNum));
            }
            if (blocked && fields[FIELD_BLOCKEDBY] && !fields[FIELD_BLOCKEDBY].options) {
              // Only write text if the field is not a single-select
              updates.push(() => setText(project.id, itemId, fields[FIELD_BLOCKEDBY].id, blocked));
            }
            if (delivVal && fields[FIELD_DELIV]) {
              // Deliverable is single-select
              const optId = getSelectOptionId(fields, FIELD_DELIV, delivVal);
              if (optId) {
                updates.push(() => setSelect(project.id, itemId, fields[FIELD_DELIV].id, optId));
              } else {
                core.warning(`Deliverable value "${delivVal}" has no matching option in Project. Available: ${
                  (fields[FIELD_DELIV].options||[]).map(o=>o.name).join(", ")
                }`);
              }
            }

            if (updates.length === 0) {
              core.info("No field updates determined from labels/body.");
              return;
            }
            for (const fn of updates) { await fn(); }
            core.info(`Updated ${updates.length} project field(s).`);

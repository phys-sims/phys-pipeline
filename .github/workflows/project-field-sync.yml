name: Project field sync (labels -> fields)

on:
  issues:
    types: [labeled, unlabeled, edited, reopened]
  pull_request_target:               # use _target_ so secrets are available on fork PRs
    types: [labeled, unlabeled, edited, ready_for_review, reopened, closed, synchronize]

jobs:
  sync:
    runs-on: ubuntu-latest
    # skip for Dependabot
    if: ${{ github.actor != 'dependabot[bot]' }}

    steps:
      - name: Assert PAT present
        run: |
          if [ -z "${{ secrets.ADD_TO_PROJECT_PAT }}" ]; then
            echo "ADD_TO_PROJECT_PAT is not available to this repo/event."
            exit 1
          fi

      - name: Sync fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}  # config: change PAT if needed
          script: |
            // ===== CONFIG =====
            const OWNER = "phys-sims";     // org or username that owns the Project
            const OWNER_KIND = "org";      // "org" or "user"

            // Prefer number (most reliable). Set TITLE to null when NUMBER is set.
            const PROJECT_NUMBER = 2;      // 
            const PROJECT_TITLE  = null;   // or exact title; keep null when using number

            const FIELD_STATUS   = "Status";    // Single-select
            const FIELD_AREA     = "Area";      // Single-select
            const FIELD_PRIORITY = "Priority";  // Single-select

            const MAP_STATUS = {
              "status:ready": "Ready",
              "status:in-progress": "In Progress",
              "status:blocked": "Blocked"
            };
            const MAP_AREA = {
              "area:phys-pipeline":  "phys-pipeline",
              "area:abcdef-sim":     "abcdef-sim",
              "area:research-utils": "research-utils",
              "area:cpa-sim":        "cpa-sim"
            };
            const MAP_PRIORITY = { "prio:P0": "P0", "prio:P1": "P1", "prio:P2": "P2" };
            // ===================

            const isIssue = !!context.payload.issue;
            const isPR    = !!context.payload.pull_request;
            if (!isIssue && !isPR) {
              core.info("Not an issue or PR event; exiting.");
              return;
            }
            const contentNodeId = isIssue
              ? context.payload.issue.node_id
              : context.payload.pull_request.node_id;

            async function listAllProjects(ownerKind, owner) {
              const nodes = [];
              let after = null;
              while (true) {
                const q =
                  ownerKind === "org"
                  ? `
                    query($login:String!, $after:String){
                      organization(login:$login){
                        projectsV2(first:100, after:$after){
                          nodes { id number title }
                          pageInfo { hasNextPage endCursor }
                        }
                      }
                    }`
                  : `
                    query($login:String!, $after:String){
                      user(login:$login){
                        projectsV2(first:100, after:$after){
                          nodes { id number title }
                          pageInfo { hasNextPage endCursor }
                        }
                      }
                    }`;
                const vars = { login: owner, after };
                const data = await github.graphql(q, vars);
                const container = ownerKind === "org" ? data.organization : data.user;
                if (!container) break;
                nodes.push(...(container.projectsV2.nodes || []));
                const pi = container.projectsV2.pageInfo;
                if (!pi?.hasNextPage) break;
                after = pi.endCursor;
              }
              return nodes;
            }

            async function resolveProject() {
              // Resolve by NUMBER first (most reliable)
              if (typeof PROJECT_NUMBER === "number") {
                const q =
                  OWNER_KIND === "org"
                  ? `
                    query($login:String!, $number:Int!){
                      organization(login:$login){
                        projectV2(number:$number){ id number title }
                      }
                    }`
                  : `
                    query($login:String!, $number:Int!){
                      user(login:$login){
                        projectV2(number:$number){ id number title }
                      }
                    }`;
                const vars = { login: OWNER, number: PROJECT_NUMBER };
                try {
                  const data = await github.graphql(q, vars);
                  const container = OWNER_KIND === "org" ? data.organization : data.user;
                  if (container?.projectV2) {
                    core.info(`Resolved project #${container.projectV2.number} "${container.projectV2.title}"`);
                    return container.projectV2;
                  }
                } catch (e) {
                  core.warning(`projectV2(number:${PROJECT_NUMBER}) lookup failed: ${e.message}`);
                }
              }

              // Fallback: resolve by TITLE with pagination (be careful with hyphen vs en-dash)
              if (PROJECT_TITLE && PROJECT_TITLE.length > 0) {
                const all = await listAllProjects(OWNER_KIND, OWNER);
                const match = all.find(p => p.title === PROJECT_TITLE);
                if (match) {
                  core.info(`Resolved project by title: #${match.number} "${match.title}"`);
                  return match;
                }
                core.setFailed(
                  `No project titled "${PROJECT_TITLE}" under ${OWNER_KIND} ${OWNER}. Found: ` +
                  all.map(p => `${p.number}:"${p.title}"`).join(", ")
                );
                return null;
              }

              core.setFailed("Set PROJECT_NUMBER or PROJECT_TITLE to resolve the project.");
              return null;
            }

            async function fetchFields(projectId) {
              const q = `
                query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2{
                      id
                      fields(first:100){
                        nodes{
                          __typename
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                          ... on ProjectV2IterationField { id name configuration { iterations { id title startDate } } }
                        }
                      }
                    }
                  }
                }`;
              const { node } = await github.graphql(q, { projectId });
              if (!node) {
                core.setFailed("Failed to fetch fields for project.");
                return null;
              }
              const byName = {};
              for (const f of node.fields.nodes || []) {
                if (f?.name) byName[f.name] = f;
              }
              return byName;
            }

            async function ensureItem(projectId, contentId) {
              const add = `
                mutation($projectId:ID!, $contentId:ID!){
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } }
                }`;
              try {
                const resp = await github.graphql(add, { projectId, contentId });
                return resp.addProjectV2ItemById.item.id;
              } catch (e) {
                core.info(`Add failed (maybe already present): ${e.message}. Scanning items...`);
              }

              let after = null;
              while (true) {
                const q = `
                  query($projectId:ID!, $after:String){
                    node(id:$projectId){
                      ... on ProjectV2{
                        items(first:100, after:$after){
                          nodes{
                            id
                            content { __typename ... on Issue { id } ... on PullRequest { id } }
                          }
                          pageInfo { hasNextPage endCursor }
                        }
                      }
                    }
                  }`;
                const { node } = await github.graphql(q, { projectId, after });
                const nodes = node?.items?.nodes || [];
                const hit = nodes.find(n => n.content && n.content.id === contentId);
                if (hit) return hit.id;
                const pi = node?.items?.pageInfo;
                if (!pi?.hasNextPage) break;
                after = pi.endCursor;
              }
              return null;
            }

            function pick(map, labelSet) {
              for (const key of Object.keys(map)) {
                if (labelSet.has(key)) return map[key];
              }
              return null;
            }

            function getSelectOptionId(fieldsByName, fieldName, optionName) {
              const f = fieldsByName[fieldName];
              if (!f || !f.options) return null;
              const opt = f.options.find(o => o.name === optionName);
              return opt ? opt.id : null;
            }

            async function setSingleSelect(projectId, itemId, fieldId, optionId) {
              const m = `
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId,
                    fieldId:$fieldId, value:{ singleSelectOptionId:$optionId }
                  }){ clientMutationId }
                }`;
              await github.graphql(m, { projectId, itemId, fieldId, optionId });
            }

            // ---- Main ----
            const project = await resolveProject();
            if (!project) return;

            const fieldsByName = await fetchFields(project.id);
            if (!fieldsByName) return;

            const itemId = await ensureItem(project.id, contentNodeId);
            if (!itemId) {
              core.setFailed("Could not find or create project item for this content.");
              return;
            }

            const labels = new Set(
              (isIssue
                ? (context.payload.issue.labels || []).map(l => l.name)
                : (context.payload.pull_request.labels || []).map(l => l.name)
              ) || []
            );

            const statusVal = pick(MAP_STATUS, labels);
            const areaVal   = pick(MAP_AREA, labels);
            const prioVal   = pick(MAP_PRIORITY, labels);

            const pending = [];

            if (statusVal) {
              const optId = getSelectOptionId(fieldsByName, FIELD_STATUS, statusVal);
              if (!optId) {
                core.warning(`No option "${statusVal}" in "${FIELD_STATUS}". Have: ${
                  (fieldsByName[FIELD_STATUS]?.options || []).map(o=>o.name).join(", ")
                }`);
              } else {
                pending.push({ fieldId: fieldsByName[FIELD_STATUS].id, optionId: optId });
              }
            }
            if (areaVal) {
              const optId = getSelectOptionId(fieldsByName, FIELD_AREA, areaVal);
              if (!optId) {
                core.warning(`No option "${areaVal}" in "${FIELD_AREA}". Have: ${
                  (fieldsByName[FIELD_AREA]?.options || []).map(o=>o.name).join(", ")
                }`);
              } else {
                pending.push({ fieldId: fieldsByName[FIELD_AREA].id, optionId: optId });
              }
            }
            if (prioVal) {
              const optId = getSelectOptionId(fieldsByName, FIELD_PRIORITY, prioVal);
              if (!optId) {
                core.warning(`No option "${prioVal}" in "${FIELD_PRIORITY}". Have: ${
                  (fieldsByName[FIELD_PRIORITY]?.options || []).map(o=>o.name).join(", ")
                }`);
              } else {
                pending.push({ fieldId: fieldsByName[FIELD_PRIORITY].id, optionId: optId });
              }
            }

            if (pending.length === 0) {
              core.info("No mapped labels present; nothing to update.");
              return;
            }

            for (const u of pending) {
              await setSingleSelect(project.id, itemId, u.fieldId, u.optionId);
            }
            core.info("Project fields updated from labels.");

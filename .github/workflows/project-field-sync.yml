name: Project field sync (labels -> fields)

on:
  issues:
    types: [opened, edited, reopened, labeled, unlabeled]
  pull_request_target:
    types: [opened, edited, reopened, ready_for_review, synchronize, labeled, unlabeled, closed]
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    if: ${{ github.actor != 'dependabot[bot]' }}

    steps:
      - name: Assert PAT present
        run: |
          if [ -z "${{ secrets.ADD_TO_PROJECT_PAT }}" ]; then
            echo "ADD_TO_PROJECT_PAT is not available to this repo/event."
            exit 1
          fi

      - name: Sync fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            // ===== CONFIG =====
            const OWNER = "phys-sims";
            const OWNER_KIND = "org";

            const PROJECT_NUMBER = 2;
            const PROJECT_TITLE  = null;

            const FIELD_STATUS   = "Status";    // Single-select
            const FIELD_AREA     = "Area";      // Single-select
            const FIELD_PRIORITY = "Priority";  // Single-select

            // Map labels -> exact Project option names (case-sensitive)
            const MAP_STATUS = {
              "status:backlog":     "Backlog",
              "status:ready":       "Ready",
              "status:in-progress": "In progress",
              "status:review":      "In review",
              "status:done":        "Done"
            };
            const MAP_AREA = {
              "area:phys-pipeline":  "phys-pipeline",
              "area:abcdef-sim":     "abcdef-sim",
              "area:research-utils": "research-utils",
              "area:cpa-sim":        "cpa-sim",
              "area:infra/docs":     "infra/docs"
            };
            const MAP_PRIORITY = { "prio:P0": "P0", "prio:P1": "P1", "prio:P2": "P2" };
            const DEFAULT_STATUS_ON_OPEN = "Backlog";
            // ===================

            function readFormField(body, heading){
              if(!body) return null;
              const re = new RegExp(`\\n###\\s*${heading}\\s*\\n([\\s\\S]*?)(\\n###|$)`,"i");
              const m = body.match(re);
              if(!m) return null;
              const val = m[1].trim().split("\n").map(s=>s.trim()).filter(Boolean)[0];
              return val || null;
            }

            function pick(map, labelSet) {
              for (const key of Object.keys(map)) {
                if (labelSet.has(key)) return map[key];
              }
              return null;
            }

            async function listAllProjects(ownerKind, owner) {
              const nodes = [];
              let after = null;
              while (true) {
                const q =
                  ownerKind === "org"
                  ? `
                    query($login:String!, $after:String){
                      organization(login:$login){
                        projectsV2(first:100, after:$after){
                          nodes { id number title }
                          pageInfo { hasNextPage endCursor }
                        }
                      }
                    }`
                  : `
                    query($login:String!, $after:String){
                      user(login:$login){
                        projectsV2(first:100, after:$after){
                          nodes { id number title }
                          pageInfo { hasNextPage endCursor }
                        }
                      }
                    }`;
                const vars = { login: owner, after };
                const data = await github.graphql(q, vars);
                const container = ownerKind === "org" ? data.organization : data.user;
                if (!container) break;
                nodes.push(...(container.projectsV2.nodes || []));
                const pi = container.projectsV2.pageInfo;
                if (!pi?.hasNextPage) break;
                after = pi.endCursor;
              }
              return nodes;
            }

            async function resolveProject() {
              if (typeof PROJECT_NUMBER === "number") {
                const q =
                  OWNER_KIND === "org"
                  ? `
                    query($login:String!, $number:Int!){
                      organization(login:$login){
                        projectV2(number:$number){ id number title }
                      }
                    }`
                  : `
                    query($login:String!, $number:Int!){
                      user(login:$login){
                        projectV2(number:$number){ id number title }
                      }
                    }`;
                const vars = { login: OWNER, number: PROJECT_NUMBER };
                try {
                  const data = await github.graphql(q, vars);
                  const container = OWNER_KIND === "org" ? data.organization : data.user;
                  if (container?.projectV2) {
                    core.info(`Resolved project #${container.projectV2.number} "${container.projectV2.title}"`);
                    return container.projectV2;
                  }
                } catch (e) {
                  core.warning(`projectV2(number:${PROJECT_NUMBER}) lookup failed: ${e.message}`);
                }
              }
              if (PROJECT_TITLE && PROJECT_TITLE.length > 0) {
                const all = await listAllProjects(OWNER_KIND, OWNER);
                const match = all.find(p => p.title === PROJECT_TITLE);
                if (match) {
                  core.info(`Resolved project by title: #${match.number} "${match.title}"`);
                  return match;
                }
                core.setFailed(
                  `No project titled "${PROJECT_TITLE}" under ${OWNER_KIND} ${OWNER}. Found: ` +
                  all.map(p => `${p.number}:"${p.title}"`).join(", ")
                );
                return null;
              }
              core.setFailed("Set PROJECT_NUMBER or PROJECT_TITLE to resolve the project.");
              return null;
            }

            async function fetchFields(projectId) {
              const q = `
                query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2{
                      id
                      fields(first:100){
                        nodes{
                          __typename
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                          ... on ProjectV2IterationField { id name configuration { iterations { id title startDate } } }
                        }
                      }
                    }
                  }
                }`;
              const { node } = await github.graphql(q, { projectId });
              if (!node) {
                core.setFailed("Failed to fetch fields for project.");
                return null;
              }
              const byName = {};
              for (const f of node.fields.nodes || []) {
                if (f?.name) byName[f.name] = f;
              }
              core.info("Project fields/options loaded.");
              return byName;
            }

            async function ensureItem(projectId, contentId) {
              const add = `
                mutation($projectId:ID!, $contentId:ID!){
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } }
                }`;
              try {
                const resp = await github.graphql(add, { projectId, contentId });
                return resp.addProjectV2ItemById.item.id;
              } catch (e) {
                core.error(`Add to project failed: ${e.message}`);
                if (e.errors) core.error(JSON.stringify(e.errors));
                core.info("Scanning items as fallback (may already exist)...");
              }

              let after = null;
              while (true) {
                const q = `
                  query($projectId:ID!, $after:String){
                    node(id:$projectId){
                      ... on ProjectV2{
                        items(first:100, after:$after){
                          nodes{
                            id
                            content { __typename ... on Issue { id } ... on PullRequest { id } }
                          }
                          pageInfo { hasNextPage endCursor }
                        }
                      }
                    }
                  }`;
                const { node } = await github.graphql(q, { projectId, after });
                const nodes = node?.items?.nodes || [];
                const hit = nodes.find(n => n.content && n.content.id === contentId);
                if (hit) return hit.id;
                const pi = node?.items?.pageInfo;
                if (!pi?.hasNextPage) break;
                after = pi.endCursor;
              }
              return null;
            }

            function getSelectOptionId(fieldsByName, fieldName, optionName) {
              const f = fieldsByName[fieldName];
              if (!f || !f.options) return null;
              const opt = f.options.find(o => o.name === optionName);
              return opt ? opt.id : null;
            }

            async function setSingleSelect(projectId, itemId, fieldId, optionId) {
              const m = `
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId,
                    fieldId:$fieldId, value:{ singleSelectOptionId:$optionId }
                  }){ clientMutationId }
                }`;
              await github.graphql(m, { projectId, itemId, fieldId, optionId });
            }

            // ---- Main ----
            const isIssue = !!context.payload.issue;
            const isPR    = !!context.payload.pull_request;
            if (!isIssue && !isPR) {
              core.info("Not an issue or PR event; exiting.");
              return;
            }

            const project = await resolveProject();
            if (!project) return;

            const fieldsByName = await fetchFields(project.id);
            if (!fieldsByName) return;

            const contentNodeId = isIssue
              ? context.payload.issue.node_id
              : context.payload.pull_request.node_id;

            const itemId = await ensureItem(project.id, contentNodeId);
            if (!itemId) {
              core.setFailed("Could not find or create project item for this content.");
              return;
            }

            const labels = new Set(
              (isIssue
                ? (context.payload.issue.labels || []).map(l => l.name)
                : (context.payload.pull_request.labels || []).map(l => l.name)
              ) || []
            );
            const body = isIssue
              ? (context.payload.issue.body || "")
              : (context.payload.pull_request?.body || "");

            const action = context.payload.action;
            const merged = isPR ? !!context.payload.pull_request.merged : false;

            // 1) labels
            let statusVal = Object.keys(MAP_STATUS).find(k => labels.has(k)) ? MAP_STATUS[[...labels].find(l => MAP_STATUS[l])] : null;
            let areaVal   = Object.keys(MAP_AREA).find(k => labels.has(k))   ? MAP_AREA[[...labels].find(l => MAP_AREA[l])]   : null;
            let prioVal   = Object.keys(MAP_PRIORITY).find(k => labels.has(k)) ? MAP_PRIORITY[[...labels].find(l => MAP_PRIORITY[l])] : null;

            // 2) form body fallback
            if (!areaVal)   areaVal   = readFormField(body, "Area");
            if (!prioVal)   prioVal   = readFormField(body, "Priority");

            // 3) sensible defaults/status rules
            if (!statusVal) {
              statusVal = DEFAULT_STATUS_ON_OPEN;           // Backlog on open
            }
            if (isPR && action === "closed" && merged) {
              statusVal = "Done";                           // auto-done on merge
            }

            const pending = [];

            if (statusVal) {
              const optId = getSelectOptionId(fieldsByName, FIELD_STATUS, statusVal);
              if (!optId) core.warning(`No option "${statusVal}" in "${FIELD_STATUS}".`);
              else pending.push({ fieldId: fieldsByName[FIELD_STATUS].id, optionId: optId });
            }
            if (areaVal) {
              const optId = getSelectOptionId(fieldsByName, FIELD_AREA, areaVal);
              if (!optId) core.warning(`No option "${areaVal}" in "${FIELD_AREA}".`);
              else pending.push({ fieldId: fieldsByName[FIELD_AREA].id, optionId: optId });
            }
            if (prioVal) {
              const optId = getSelectOptionId(fieldsByName, FIELD_PRIORITY, prioVal);
              if (!optId) core.warning(`No option "${prioVal}" in "${FIELD_PRIORITY}".`);
              else pending.push({ fieldId: fieldsByName[FIELD_PRIORITY].id, optionId: optId });
            }

            if (pending.length === 0) {
              core.info("No mapped labels/body values found; nothing to update.");
              return;
            }

            for (const u of pending) {
              await setSingleSelect(project.id, itemId, u.fieldId, u.optionId);
            }
            core.info(`Project fields updated (${pending.length} field(s)).`);
